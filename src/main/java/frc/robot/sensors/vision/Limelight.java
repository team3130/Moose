package frc.robot.sensors.vision;import edu.wpi.first.math.filter.MedianFilter;import edu.wpi.first.networktables.NetworkTable;import edu.wpi.first.networktables.NetworkTableEntry;import edu.wpi.first.networktables.NetworkTableInstance;import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;import edu.wpi.first.math.Matrix;import edu.wpi.first.math.numbers.N1;import edu.wpi.first.math.numbers.N3;import frc.robot.RobotMap;import frc.robot.subsystems.Chassis;public class Limelight {private static Limelight m_pInstance;public static Limelight GetInstance() {if (m_pInstance == null) m_pInstance = new Limelight();return m_pInstance;}NetworkTable visionTable;private NetworkTableEntry tv;private NetworkTableEntry tx;private NetworkTableEntry ty;private NetworkTableEntry ta;private NetworkTableEntry ts;private MedianFilter txFilter;private MedianFilter tyFilter;private MedianFilter tsFilter;private double x_targetOffsetAngle;private double y_targetOffsetAngle;private double area;private double skew;private Matrix<N3, N3> rotation;private Matrix<N3, N1> translation;private Matrix<N3, N1> tilt;private Matrix<N3, N1> realVector;private Matrix<N3, N1> sideVector;protected Limelight() {visionTable = NetworkTableInstance.getDefault().getTable("limelight");tv = visionTable.getEntry("tv");tx = visionTable.getEntry("tx");ty = visionTable.getEntry("ty");ta = visionTable.getEntry("ta");ts = visionTable.getEntry("ts");txFilter = new MedianFilter(RobotMap.kLimelightFilterBufferSize);tyFilter = new MedianFilter(RobotMap.kLimelightFilterBufferSize);tsFilter = new MedianFilter(RobotMap.kLimelightFilterBufferSize);x_targetOffsetAngle = 0.0;y_targetOffsetAngle = 0.0;area = 0.0;skew = 0.0;Matrix<N3, N1> rVec = Algebra.buildVector(Math.toRadians(RobotMap.kLimelightPitch),Math.toRadians(RobotMap.kLimelightYaw),Math.toRadians(RobotMap.kLimelightRoll));rotation = Algebra.Rodrigues(rVec);translation = Algebra.buildVector(RobotMap.kLimelightOffset,RobotMap.kLimelightHeight,RobotMap.kLimelightLength);tilt = Algebra.buildVector(Math.toRadians(0),0,Math.toRadians(0));realVector = Algebra.buildVector(0, 0, 0);sideVector = Algebra.buildVector(0, 0, 0);}public double getTx() {return tx.getDouble(0.0);}public double getTy() {return ty.getDouble(0.0);}public double getArea() {return ta.getDouble(0.0);}public double getSkew() {return ts.getDouble(0.0);}public double getLatency(){return visionTable.getEntry("tl").getDouble(0) + RobotMap.kLimelightLatencyMs;}public void updateData(Chassis chassis) {x_targetOffsetAngle = txFilter.calculate(getTx());y_targetOffsetAngle = tyFilter.calculate(getTy());area = getArea();skew = tsFilter.calculate(getSkew());realVector = calcPosition(x_targetOffsetAngle, y_targetOffsetAngle, chassis);double realSkew = Math.toRadians(skew < -45 ? skew + 90 : skew);double side_x = x_targetOffsetAngle + Math.cos(realSkew);double side_y = y_targetOffsetAngle + Math.sin(realSkew);sideVector = calcPosition(side_x, side_y, chassis);}Matrix<N3,N3> turretRotation(double heading) {Matrix<N3,N3> turn = Algebra.Rodrigues(Algebra.buildVector(0, Math.toRadians(-heading), 0));return Algebra.Rodrigues(turn.times(tilt));}public Matrix<N3, N1> levelVector(double ax, double ay, double heading) {double ux = Math.tan(Math.toRadians(ax));double uy = Math.tan(Math.toRadians(ay));return turretRotation(heading).times(rotation.times(Algebra.buildVector(ux, uy, 1)));}public Matrix<N3, N1> calcPosition(double ax, double ay, Chassis chassis) {Matrix<N3, N1> v0 = levelVector(ax, ay, chassis.getAngle());double c = (RobotMap.VISIONTARGETHEIGHT - RobotMap.kLimelightHeight) / v0.get(1, 0);Matrix<N3, N1> v = v0.times(c);Matrix<N3, N1> a = translation.plus(v);return a;}public boolean hasTrack() {return tv.getDouble(0.0) == 1.0;}public double getTargetRotationTan() {Matrix<N3,N1> edge = sideVector.minus(realVector);return -edge.get(2, 0) / edge.get(0, 0);}public Matrix<N3,N1> getInnerTarget() {double depth = 29.25;double alpha = Math.atan(getTargetRotationTan());return Algebra.buildVector(depth * Math.sin(alpha),0,depth * Math.cos(alpha));}public double getDegHorizontalError() {double alpha = Math.toDegrees(Math.atan2(realVector.get(0, 0), realVector.get(2, 0)));Matrix<N3,N1> inner = getInnerTarget();double yawAdj = 0;System.out.println("Yaw Adjustment: " + yawAdj);if (Math.abs(inner.get(0, 0)) > 5) return -1.0 * alpha + yawAdj;Matrix<N3,N1> adjustedVec = realVector.minus(inner);return -1.0 * Math.toDegrees(Math.atan2(adjustedVec.get(0, 0), adjustedVec.get(2, 0))) + yawAdj;}public double getDistanceToTarget() {if (Limelight.GetInstance().hasTrack()) {Matrix<N3, N1> projection = realVector.copy();projection.set(1, 0, 0.0);return projection.normF();} else {return 0.0;}}public double calibrate(Chassis chassis) {updateData(chassis);double height = RobotMap.VISIONTARGETHEIGHT - RobotMap.kLimelightHeight;double distance = RobotMap.kLimelightCalibrationDist;return Math.toDegrees(Math.atan2(height, distance)) - y_targetOffsetAngle;}public void setLedState(boolean isOn) {if (isOn) {visionTable.getEntry("ledMode").setNumber(3);} else {visionTable.getEntry("ledMode").setNumber(1);}}public void setPipeline(double pipelineNumber) {visionTable.getEntry("pipeline").setNumber(pipelineNumber);}public double getYawAdjustment(){double distance = getDistanceToTarget();double yawCalc = 0.0;if(distance >= 220){yawCalc = RobotMap.kLimelightYaw *Math.min(1.0, Math.max(0.0, (distance - 190)) / (290 - 190));}return yawCalc;}public void outputToShuffleboard(Chassis chassis) {Limelight o = GetInstance();SmartDashboard.putNumber("Limelight X", o.x_targetOffsetAngle);SmartDashboard.putNumber("Limelight Y", o.y_targetOffsetAngle);SmartDashboard.putNumber("Limelight Distance", o.getDistanceToTarget());SmartDashboard.putNumber("Limelight Area", o.area);SmartDashboard.putBoolean("Limelight Has Target", o.hasTrack());SmartDashboard.putNumber("Limelight mounting angle", o.calibrate(chassis));SmartDashboard.putNumber("Limelight Target Rotation", o.getTargetRotationTan());}}