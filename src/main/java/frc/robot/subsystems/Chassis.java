package frc.robot.subsystems;import java.util.Map;import com.ctre.phoenix.motorcontrol.NeutralMode;import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;import edu.wpi.first.math.controller.PIDController;import edu.wpi.first.math.controller.SimpleMotorFeedforward;import edu.wpi.first.math.geometry.Pose2d;import edu.wpi.first.math.geometry.Rotation2d;import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;import edu.wpi.first.math.util.Units;import edu.wpi.first.networktables.NetworkTableEntry;import edu.wpi.first.wpilibj.PneumaticsModuleType;import edu.wpi.first.wpilibj.Solenoid;import edu.wpi.first.wpilibj.drive.DifferentialDrive;import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;import edu.wpi.first.wpilibj2.command.SubsystemBase;import frc.robot.RobotMap;import frc.robot.commands.Chassis.DefaultDrive;import frc.robot.sensors.Navx;public class Chassis extends SubsystemBase {private Navx m_navx = Navx.GetInstance();private WPI_TalonFX m_rightMotorFront;private WPI_TalonFX m_rightMotorBack;private WPI_TalonFX m_leftMotorFront;private WPI_TalonFX m_leftMotorBack;private Solenoid m_shifter;private MotorControllerGroup m_motorsRight;private MotorControllerGroup m_motorsLeft;private DifferentialDriveOdometry m_odometry;private DifferentialDriveKinematics m_kinematics;private DifferentialDrive m_drive;private SimpleMotorFeedforward m_feedforward;private PIDController m_leftPIDController;private PIDController m_rightPIDConttroller;private ShuffleboardTab tab = Shuffleboard.getTab("Chassis");private NetworkTableEntry P = tab.add("Chassis P", .5).getEntry();private NetworkTableEntry I = tab.add("Chassis I", 0).getEntry();private NetworkTableEntry D = tab.add("Chassis D", 0).getEntry();private NetworkTableEntry sliderMove = tab.add("Move Speed Sensitivity", 7.5).withWidget(BuiltInWidgets.kNumberSlider).withProperties(Map.of("min", 0, "max", 10)).getEntry();private NetworkTableEntry sliderTurn = tab.add("Turn Speed Sensitivity", 7.5).withWidget(BuiltInWidgets.kNumberSlider).withProperties(Map.of("min", 0, "max", 10)).getEntry();public double getMoveSpeedSensitivityFromShuffleboard() {return sliderMove.getDouble(7.5);}public double getTurnSpeedSensitivityFromShuffleboard() {return sliderTurn.getDouble(7.5);}public Chassis() {m_rightMotorFront = new WPI_TalonFX(RobotMap.CAN_CHASSIS_MOTOR_FRONTR);m_leftMotorFront = new WPI_TalonFX(RobotMap.CAN_CHASSIS_MOTOR_FRONTL);m_rightMotorBack = new WPI_TalonFX(RobotMap.CAN_CHASSIS_MOTOR_BACKR);m_leftMotorBack = new WPI_TalonFX(RobotMap.CAN_CHASSIS_MOTOR_BACKL);m_rightMotorFront.configFactoryDefault();m_leftMotorFront.configFactoryDefault();m_rightMotorBack.configFactoryDefault();m_leftMotorBack.configFactoryDefault();configureBreakMode(true);m_rightMotorFront.configVoltageCompSaturation(RobotMap.kChassisMaxVoltage);m_leftMotorFront.configVoltageCompSaturation(RobotMap.kChassisMaxVoltage);m_rightMotorFront.enableVoltageCompensation(true);m_leftMotorFront.enableVoltageCompensation(true);m_rightMotorFront.setInverted(true);m_leftMotorFront.setInverted(false);m_rightMotorBack.setInverted(true);m_leftMotorBack.setInverted(false);m_motorsRight = new MotorControllerGroup(m_rightMotorFront, m_rightMotorBack);m_motorsLeft = new MotorControllerGroup(m_leftMotorFront, m_leftMotorBack);m_drive = new DifferentialDrive(m_motorsLeft, m_motorsRight);m_drive.setDeadband(RobotMap.kDriveDeadband);m_drive.setSafetyEnabled(false);m_feedforward = new SimpleMotorFeedforward(RobotMap.lowGearkS, RobotMap.lowGearkV, RobotMap.lowGearkA);m_leftPIDController = new PIDController(2.05, 0, 0);m_rightPIDConttroller = new PIDController(2.05, 0, 0);m_kinematics = new DifferentialDriveKinematics(RobotMap.trackDistance);m_odometry = new DifferentialDriveOdometry(new Rotation2d(Units.degreesToRadians(Navx.getAngle())));m_shifter = new Solenoid(RobotMap.CAN_PNMMODULE, PneumaticsModuleType.CTREPCM, RobotMap.PNM_Shift);m_shifter.set(false);}public void driveTank(double moveL, double moveR, boolean squaredInputs) {m_drive.tankDrive(moveL, moveR, squaredInputs);}public void configureBreakMode(boolean brake) {if (brake) {m_leftMotorFront.setNeutralMode(NeutralMode.Brake);m_rightMotorFront.setNeutralMode(NeutralMode.Brake);m_leftMotorBack.setNeutralMode(NeutralMode.Brake);m_rightMotorBack.setNeutralMode(NeutralMode.Brake);} else {m_leftMotorFront.setNeutralMode(NeutralMode.Coast);m_rightMotorFront.setNeutralMode(NeutralMode.Coast);m_leftMotorBack.setNeutralMode(NeutralMode.Coast);m_rightMotorBack.setNeutralMode(NeutralMode.Coast);}}private double getDistanceLowGearR() {return m_rightMotorFront.getSelectedSensorPosition() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisLowGearRatio) * ((RobotMap.kWheelDiameter) * Math.PI);}private double getDistanceLowGearL() {return m_leftMotorFront.getSelectedSensorPosition() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisLowGearRatio) * ((RobotMap.kWheelDiameter) * Math.PI);}private double getDistanceHighGearL() {return m_leftMotorFront.getSelectedSensorPosition() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisHighGearRatio) * ((RobotMap.kWheelDiameter) * Math.PI);}private double getDistanceHighGearR() {return m_rightMotorFront.getSelectedSensorPosition() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisHighGearRatio) * ((RobotMap.kWheelDiameter) * Math.PI);}public double getSpeedLowGearL() {return (m_leftMotorFront.getSelectedSensorVelocity() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisLowGearRatio) * (Math.PI * RobotMap.kWheelDiameter)) * 10;}public double getSpeedLowGearR() {return (m_rightMotorFront.getSelectedSensorVelocity() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisLowGearRatio) * (Math.PI * RobotMap.kWheelDiameter)) * 10;}public double getSpeedHighGearL() {return (m_leftMotorFront.getSelectedSensorVelocity() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisHighGearRatio) * (Math.PI * RobotMap.kWheelDiameter)) * 10;}public double getSpeedHighGearR() {return (m_rightMotorFront.getSelectedSensorVelocity() / RobotMap.kEncoderResolution * (1 / RobotMap.kChassisHighGearRatio) * (Math.PI * RobotMap.kWheelDiameter)) * 10;}@Override public void periodic() {if (!m_shifter.get()) {m_odometry.update(Navx.getRotation(), getDistanceLowGearL(), getDistanceLowGearR());} else {m_odometry.update(Navx.getRotation(), getDistanceHighGearL(), getDistanceHighGearR());}}public void driveArcade(double moveThrottle, double turnThrottle, boolean squaredInputs) {m_drive.arcadeDrive(moveThrottle, turnThrottle, squaredInputs);}public static double getHeading() {return Navx.getAngle();}private void resetEncoders() {m_leftMotorFront.setSelectedSensorPosition(0);m_rightMotorFront.setSelectedSensorPosition(0);}private void resetOdometry(Pose2d pose) {resetEncoders();Navx.resetNavX();m_odometry.resetPosition(pose, Navx.getRotation());}public double getSpeed() {if (m_shifter.get()) {return 0.5 * (getSpeedHighGearL() + getSpeedHighGearR());} else {return 0.5 * (getSpeedLowGearL() + getSpeedLowGearR());}}public void configRampRate(double maxRampRateSeconds) {m_rightMotorFront.configOpenloopRamp(maxRampRateSeconds);m_leftMotorFront.configOpenloopRamp(maxRampRateSeconds);}public boolean isShifted() {return m_shifter.get();}public void shift(boolean shiftVal) {m_shifter.set(shiftVal);}public void shift() {m_shifter.toggle();}public double getAngle() {if (Navx.getNavxPresent()) {return Navx.getAngle();} else {return 0;}}public Pose2d getPose() {return m_odometry.getPoseMeters();}public SimpleMotorFeedforward getFeedforward() {return m_feedforward;}public DifferentialDriveKinematics getmKinematics() {return m_kinematics;}public DifferentialDriveWheelSpeeds getSpeeds() {if (m_shifter.get()) {return new DifferentialDriveWheelSpeeds(getSpeedHighGearL() / 10, getSpeedHighGearR() / 10);} else {return new DifferentialDriveWheelSpeeds(getSpeedLowGearL() / 10, getSpeedLowGearR() / 10);}}public PIDController getleftPIDController() {return m_leftPIDController;}public PIDController getRightPIDController() {return m_rightPIDConttroller;}public void setOutput(double leftVolts, double rightVolts) {m_leftMotorFront.setVoltage(leftVolts);m_rightMotorFront.setVoltage(rightVolts);m_drive.feed();}public void outputToShuffleboard() {SmartDashboard.putNumber("Chassis Right Velocity", (isShifted()) ? getSpeedHighGearR() : getSpeedLowGearR());SmartDashboard.putNumber("Chassis Left Velocity", (isShifted()) ? getSpeedHighGearL() : getSpeedLowGearL());SmartDashboard.putNumber("Chassis Right Output %", m_rightMotorFront.getMotorOutputPercent());SmartDashboard.putNumber("Chassis Left Output %", m_leftMotorFront.getMotorOutputPercent());SmartDashboard.putNumber("Chassis Distance R", (isShifted()) ? getDistanceHighGearR() : getDistanceLowGearR());SmartDashboard.putNumber("Chassis Distance L", (isShifted()) ? getDistanceHighGearL() : getDistanceLowGearL());SmartDashboard.putNumber("Robot position X", m_odometry.getPoseMeters().getX());SmartDashboard.putNumber("Robot position Y", m_odometry.getPoseMeters().getY());SmartDashboard.putNumber("Robot rotation", m_odometry.getPoseMeters().getRotation().getDegrees());SmartDashboard.putBoolean("Shifted", m_shifter.get());}}